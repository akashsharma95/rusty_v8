/* automatically generated by rust-bindgen 0.59.1 */

pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 110300;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = u128;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
  pub __mbstate8: [::std::os::raw::c_char; 128usize],
  pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
  assert_eq!(
    ::std::mem::size_of::<__mbstate_t>(),
    128usize,
    concat!("Size of: ", stringify!(__mbstate_t))
  );
  assert_eq!(
    ::std::mem::align_of::<__mbstate_t>(),
    8usize,
    concat!("Alignment of ", stringify!(__mbstate_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__mbstate_t),
      "::",
      stringify!(__mbstate8)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__mbstate_t),
      "::",
      stringify!(_mbstateL)
    )
  );
}
impl Default for __mbstate_t {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
  pub __routine: ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
  >,
  pub __arg: *mut ::std::os::raw::c_void,
  pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
  assert_eq!(
    ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
    24usize,
    concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
  );
  assert_eq!(
    ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
    8usize,
    concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_pthread_handler_rec),
      "::",
      stringify!(__routine)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_pthread_handler_rec),
      "::",
      stringify!(__arg)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__darwin_pthread_handler_rec),
      "::",
      stringify!(__next)
    )
  );
}
impl Default for __darwin_pthread_handler_rec {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
  pub __sig: ::std::os::raw::c_long,
  pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
  assert_eq!(
    ::std::mem::size_of::<_opaque_pthread_attr_t>(),
    64usize,
    concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
  );
  assert_eq!(
    ::std::mem::align_of::<_opaque_pthread_attr_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_attr_t),
      "::",
      stringify!(__sig)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_attr_t),
      "::",
      stringify!(__opaque)
    )
  );
}
impl Default for _opaque_pthread_attr_t {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
  pub __sig: ::std::os::raw::c_long,
  pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
  assert_eq!(
    ::std::mem::size_of::<_opaque_pthread_cond_t>(),
    48usize,
    concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
  );
  assert_eq!(
    ::std::mem::align_of::<_opaque_pthread_cond_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_cond_t),
      "::",
      stringify!(__sig)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_cond_t),
      "::",
      stringify!(__opaque)
    )
  );
}
impl Default for _opaque_pthread_cond_t {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
  pub __sig: ::std::os::raw::c_long,
  pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
  assert_eq!(
    ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
    16usize,
    concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
  );
  assert_eq!(
    ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_condattr_t),
      "::",
      stringify!(__sig)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_condattr_t),
      "::",
      stringify!(__opaque)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
  pub __sig: ::std::os::raw::c_long,
  pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
  assert_eq!(
    ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
    64usize,
    concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
  );
  assert_eq!(
    ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_mutex_t),
      "::",
      stringify!(__sig)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_mutex_t),
      "::",
      stringify!(__opaque)
    )
  );
}
impl Default for _opaque_pthread_mutex_t {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
  pub __sig: ::std::os::raw::c_long,
  pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
  assert_eq!(
    ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
    16usize,
    concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
  );
  assert_eq!(
    ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_mutexattr_t),
      "::",
      stringify!(__sig)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_mutexattr_t),
      "::",
      stringify!(__opaque)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_once_t {
  pub __sig: ::std::os::raw::c_long,
  pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
  assert_eq!(
    ::std::mem::size_of::<_opaque_pthread_once_t>(),
    16usize,
    concat!("Size of: ", stringify!(_opaque_pthread_once_t))
  );
  assert_eq!(
    ::std::mem::align_of::<_opaque_pthread_once_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_once_t),
      "::",
      stringify!(__sig)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_once_t),
      "::",
      stringify!(__opaque)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
  pub __sig: ::std::os::raw::c_long,
  pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
  assert_eq!(
    ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
    200usize,
    concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
  );
  assert_eq!(
    ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_rwlock_t),
      "::",
      stringify!(__sig)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_rwlock_t),
      "::",
      stringify!(__opaque)
    )
  );
}
impl Default for _opaque_pthread_rwlock_t {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
  pub __sig: ::std::os::raw::c_long,
  pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
  assert_eq!(
    ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
    24usize,
    concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
  );
  assert_eq!(
    ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_rwlockattr_t),
      "::",
      stringify!(__sig)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_rwlockattr_t),
      "::",
      stringify!(__opaque)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
  pub __sig: ::std::os::raw::c_long,
  pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
  pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
  assert_eq!(
    ::std::mem::size_of::<_opaque_pthread_t>(),
    8192usize,
    concat!("Size of: ", stringify!(_opaque_pthread_t))
  );
  assert_eq!(
    ::std::mem::align_of::<_opaque_pthread_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_opaque_pthread_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_t),
      "::",
      stringify!(__sig)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_t),
      "::",
      stringify!(__cleanup_stack)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_opaque_pthread_t),
      "::",
      stringify!(__opaque)
    )
  );
}
impl Default for _opaque_pthread_t {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
extern "C" {
  pub fn memchr(
    __s: *const ::std::os::raw::c_void,
    __c: ::std::os::raw::c_int,
    __n: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn memcmp(
    __s1: *const ::std::os::raw::c_void,
    __s2: *const ::std::os::raw::c_void,
    __n: ::std::os::raw::c_ulong,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn memcpy(
    __dst: *mut ::std::os::raw::c_void,
    __src: *const ::std::os::raw::c_void,
    __n: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn memmove(
    __dst: *mut ::std::os::raw::c_void,
    __src: *const ::std::os::raw::c_void,
    __len: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn memset(
    __b: *mut ::std::os::raw::c_void,
    __c: ::std::os::raw::c_int,
    __len: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn strcat(
    __s1: *mut ::std::os::raw::c_char,
    __s2: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strchr(
    __s: *const ::std::os::raw::c_char,
    __c: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strcmp(
    __s1: *const ::std::os::raw::c_char,
    __s2: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn strcoll(
    __s1: *const ::std::os::raw::c_char,
    __s2: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn strcpy(
    __dst: *mut ::std::os::raw::c_char,
    __src: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strcspn(
    __s: *const ::std::os::raw::c_char,
    __charset: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn strerror(
    __errnum: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn strncat(
    __s1: *mut ::std::os::raw::c_char,
    __s2: *const ::std::os::raw::c_char,
    __n: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strncmp(
    __s1: *const ::std::os::raw::c_char,
    __s2: *const ::std::os::raw::c_char,
    __n: ::std::os::raw::c_ulong,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn strncpy(
    __dst: *mut ::std::os::raw::c_char,
    __src: *const ::std::os::raw::c_char,
    __n: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strpbrk(
    __s: *const ::std::os::raw::c_char,
    __charset: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strrchr(
    __s: *const ::std::os::raw::c_char,
    __c: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strspn(
    __s: *const ::std::os::raw::c_char,
    __charset: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn strstr(
    __big: *const ::std::os::raw::c_char,
    __little: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strtok(
    __str: *mut ::std::os::raw::c_char,
    __sep: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strxfrm(
    __s1: *mut ::std::os::raw::c_char,
    __s2: *const ::std::os::raw::c_char,
    __n: ::std::os::raw::c_ulong,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn strtok_r(
    __str: *mut ::std::os::raw::c_char,
    __sep: *const ::std::os::raw::c_char,
    __lasts: *mut *mut ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strerror_r(
    __errnum: ::std::os::raw::c_int,
    __strerrbuf: *mut ::std::os::raw::c_char,
    __buflen: size_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn strdup(
    __s1: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn memccpy(
    __dst: *mut ::std::os::raw::c_void,
    __src: *const ::std::os::raw::c_void,
    __c: ::std::os::raw::c_int,
    __n: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn stpcpy(
    __dst: *mut ::std::os::raw::c_char,
    __src: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn stpncpy(
    __dst: *mut ::std::os::raw::c_char,
    __src: *const ::std::os::raw::c_char,
    __n: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strndup(
    __s1: *const ::std::os::raw::c_char,
    __n: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: size_t) -> size_t;
}
extern "C" {
  pub fn strsignal(__sig: ::std::os::raw::c_int)
    -> *mut ::std::os::raw::c_char;
}
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
extern "C" {
  pub fn memset_s(
    __s: *mut ::std::os::raw::c_void,
    __smax: rsize_t,
    __c: ::std::os::raw::c_int,
    __n: rsize_t,
  ) -> errno_t;
}
pub type ssize_t = __darwin_ssize_t;
extern "C" {
  pub fn memmem(
    __big: *const ::std::os::raw::c_void,
    __big_len: size_t,
    __little: *const ::std::os::raw::c_void,
    __little_len: size_t,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn memset_pattern4(
    __b: *mut ::std::os::raw::c_void,
    __pattern4: *const ::std::os::raw::c_void,
    __len: size_t,
  );
}
extern "C" {
  pub fn memset_pattern8(
    __b: *mut ::std::os::raw::c_void,
    __pattern8: *const ::std::os::raw::c_void,
    __len: size_t,
  );
}
extern "C" {
  pub fn memset_pattern16(
    __b: *mut ::std::os::raw::c_void,
    __pattern16: *const ::std::os::raw::c_void,
    __len: size_t,
  );
}
extern "C" {
  pub fn strcasestr(
    __big: *const ::std::os::raw::c_char,
    __little: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strnstr(
    __big: *const ::std::os::raw::c_char,
    __little: *const ::std::os::raw::c_char,
    __len: size_t,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strlcat(
    __dst: *mut ::std::os::raw::c_char,
    __source: *const ::std::os::raw::c_char,
    __size: ::std::os::raw::c_ulong,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn strlcpy(
    __dst: *mut ::std::os::raw::c_char,
    __source: *const ::std::os::raw::c_char,
    __size: ::std::os::raw::c_ulong,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn strmode(
    __mode: ::std::os::raw::c_int,
    __bp: *mut ::std::os::raw::c_char,
  );
}
extern "C" {
  pub fn strsep(
    __stringp: *mut *mut ::std::os::raw::c_char,
    __delim: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn swab(
    arg1: *const ::std::os::raw::c_void,
    arg2: *mut ::std::os::raw::c_void,
    arg3: ssize_t,
  );
}
extern "C" {
  pub fn timingsafe_bcmp(
    __b1: *const ::std::os::raw::c_void,
    __b2: *const ::std::os::raw::c_void,
    __len: size_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn strsignal_r(
    __sig: ::std::os::raw::c_int,
    __strsignalbuf: *mut ::std::os::raw::c_char,
    __buflen: size_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn bcmp(
    arg1: *const ::std::os::raw::c_void,
    arg2: *const ::std::os::raw::c_void,
    arg3: ::std::os::raw::c_ulong,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn bcopy(
    arg1: *const ::std::os::raw::c_void,
    arg2: *mut ::std::os::raw::c_void,
    arg3: size_t,
  );
}
extern "C" {
  pub fn bzero(
    arg1: *mut ::std::os::raw::c_void,
    arg2: ::std::os::raw::c_ulong,
  );
}
extern "C" {
  pub fn index(
    arg1: *const ::std::os::raw::c_char,
    arg2: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn rindex(
    arg1: *const ::std::os::raw::c_char,
    arg2: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn strcasecmp(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn strncasecmp(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_ulong,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __assert_rtn(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
    arg4: *const ::std::os::raw::c_char,
  );
}
pub type byte_t = ::std::os::raw::c_char;
pub type float32_t = f32;
pub type float64_t = f64;
pub type wasm_byte_t = byte_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_byte_vec_t {
  pub size: size_t,
  pub data: *mut wasm_byte_t,
}
#[test]
fn bindgen_test_layout_wasm_byte_vec_t() {
  assert_eq!(
    ::std::mem::size_of::<wasm_byte_vec_t>(),
    16usize,
    concat!("Size of: ", stringify!(wasm_byte_vec_t))
  );
  assert_eq!(
    ::std::mem::align_of::<wasm_byte_vec_t>(),
    8usize,
    concat!("Alignment of ", stringify!(wasm_byte_vec_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_byte_vec_t>())).size as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_byte_vec_t),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_byte_vec_t>())).data as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_byte_vec_t),
      "::",
      stringify!(data)
    )
  );
}
impl Default for wasm_byte_vec_t {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
extern "C" {
  pub fn wasm_byte_vec_new_empty(out: *mut wasm_byte_vec_t);
}
extern "C" {
  pub fn wasm_byte_vec_new_uninitialized(
    out: *mut wasm_byte_vec_t,
    arg1: size_t,
  );
}
extern "C" {
  pub fn wasm_byte_vec_new(
    out: *mut wasm_byte_vec_t,
    arg1: size_t,
    arg2: *const wasm_byte_t,
  );
}
extern "C" {
  pub fn wasm_byte_vec_copy(
    out: *mut wasm_byte_vec_t,
    arg1: *mut wasm_byte_vec_t,
  );
}
extern "C" {
  pub fn wasm_byte_vec_delete(arg1: *mut wasm_byte_vec_t);
}
pub type wasm_name_t = wasm_byte_vec_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_config_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_config_delete(arg1: *mut wasm_config_t);
}
extern "C" {
  #[doc = ""]
  pub fn wasm_config_new() -> *mut wasm_config_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_engine_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_engine_delete(arg1: *mut wasm_engine_t);
}
extern "C" {
  pub fn wasm_engine_new() -> *mut wasm_engine_t;
}
extern "C" {
  pub fn wasm_engine_new_with_config(
    arg1: *mut wasm_config_t,
  ) -> *mut wasm_engine_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_store_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_store_delete(arg1: *mut wasm_store_t);
}
extern "C" {
  pub fn wasm_store_new(arg1: *mut wasm_engine_t) -> *mut wasm_store_t;
}
#[doc = ""]
pub type wasm_mutability_t = u8;
pub const wasm_mutability_enum_WASM_CONST: wasm_mutability_enum = 0;
pub const wasm_mutability_enum_WASM_VAR: wasm_mutability_enum = 1;
pub type wasm_mutability_enum = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wasm_limits_t {
  pub min: u32,
  pub max: u32,
}
#[test]
fn bindgen_test_layout_wasm_limits_t() {
  assert_eq!(
    ::std::mem::size_of::<wasm_limits_t>(),
    8usize,
    concat!("Size of: ", stringify!(wasm_limits_t))
  );
  assert_eq!(
    ::std::mem::align_of::<wasm_limits_t>(),
    4usize,
    concat!("Alignment of ", stringify!(wasm_limits_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_limits_t>())).min as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_limits_t),
      "::",
      stringify!(min)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_limits_t>())).max as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_limits_t),
      "::",
      stringify!(max)
    )
  );
}
pub const wasm_limits_max_default: u32 = 4294967295;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_valtype_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_valtype_delete(arg1: *mut wasm_valtype_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_valtype_vec_t {
  pub size: size_t,
  pub data: *mut *mut wasm_valtype_t,
}
#[test]
fn bindgen_test_layout_wasm_valtype_vec_t() {
  assert_eq!(
    ::std::mem::size_of::<wasm_valtype_vec_t>(),
    16usize,
    concat!("Size of: ", stringify!(wasm_valtype_vec_t))
  );
  assert_eq!(
    ::std::mem::align_of::<wasm_valtype_vec_t>(),
    8usize,
    concat!("Alignment of ", stringify!(wasm_valtype_vec_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_valtype_vec_t>())).size as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_valtype_vec_t),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_valtype_vec_t>())).data as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_valtype_vec_t),
      "::",
      stringify!(data)
    )
  );
}
impl Default for wasm_valtype_vec_t {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
extern "C" {
  pub fn wasm_valtype_vec_new_empty(out: *mut wasm_valtype_vec_t);
}
extern "C" {
  pub fn wasm_valtype_vec_new_uninitialized(
    out: *mut wasm_valtype_vec_t,
    arg1: size_t,
  );
}
extern "C" {
  pub fn wasm_valtype_vec_new(
    out: *mut wasm_valtype_vec_t,
    arg1: size_t,
    arg2: *const *mut wasm_valtype_t,
  );
}
extern "C" {
  pub fn wasm_valtype_vec_copy(
    out: *mut wasm_valtype_vec_t,
    arg1: *mut wasm_valtype_vec_t,
  );
}
extern "C" {
  pub fn wasm_valtype_vec_delete(arg1: *mut wasm_valtype_vec_t);
}
extern "C" {
  pub fn wasm_valtype_copy(arg1: *mut wasm_valtype_t) -> *mut wasm_valtype_t;
}
pub type wasm_valkind_t = u8;
pub const wasm_valkind_enum_WASM_I32: wasm_valkind_enum = 0;
pub const wasm_valkind_enum_WASM_I64: wasm_valkind_enum = 1;
pub const wasm_valkind_enum_WASM_F32: wasm_valkind_enum = 2;
pub const wasm_valkind_enum_WASM_F64: wasm_valkind_enum = 3;
pub const wasm_valkind_enum_WASM_ANYREF: wasm_valkind_enum = 128;
pub const wasm_valkind_enum_WASM_FUNCREF: wasm_valkind_enum = 129;
pub type wasm_valkind_enum = ::std::os::raw::c_uint;
extern "C" {
  pub fn wasm_valtype_new(arg1: wasm_valkind_t) -> *mut wasm_valtype_t;
}
extern "C" {
  pub fn wasm_valtype_kind(arg1: *const wasm_valtype_t) -> wasm_valkind_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_functype_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_functype_delete(arg1: *mut wasm_functype_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_functype_vec_t {
  pub size: size_t,
  pub data: *mut *mut wasm_functype_t,
}
#[test]
fn bindgen_test_layout_wasm_functype_vec_t() {
  assert_eq!(
    ::std::mem::size_of::<wasm_functype_vec_t>(),
    16usize,
    concat!("Size of: ", stringify!(wasm_functype_vec_t))
  );
  assert_eq!(
    ::std::mem::align_of::<wasm_functype_vec_t>(),
    8usize,
    concat!("Alignment of ", stringify!(wasm_functype_vec_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_functype_vec_t>())).size as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_functype_vec_t),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_functype_vec_t>())).data as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_functype_vec_t),
      "::",
      stringify!(data)
    )
  );
}
impl Default for wasm_functype_vec_t {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
extern "C" {
  pub fn wasm_functype_vec_new_empty(out: *mut wasm_functype_vec_t);
}
extern "C" {
  pub fn wasm_functype_vec_new_uninitialized(
    out: *mut wasm_functype_vec_t,
    arg1: size_t,
  );
}
extern "C" {
  pub fn wasm_functype_vec_new(
    out: *mut wasm_functype_vec_t,
    arg1: size_t,
    arg2: *const *mut wasm_functype_t,
  );
}
extern "C" {
  pub fn wasm_functype_vec_copy(
    out: *mut wasm_functype_vec_t,
    arg1: *mut wasm_functype_vec_t,
  );
}
extern "C" {
  pub fn wasm_functype_vec_delete(arg1: *mut wasm_functype_vec_t);
}
extern "C" {
  pub fn wasm_functype_copy(arg1: *mut wasm_functype_t)
    -> *mut wasm_functype_t;
}
extern "C" {
  pub fn wasm_functype_new(
    params: *mut wasm_valtype_vec_t,
    results: *mut wasm_valtype_vec_t,
  ) -> *mut wasm_functype_t;
}
extern "C" {
  pub fn wasm_functype_params(
    arg1: *const wasm_functype_t,
  ) -> *const wasm_valtype_vec_t;
}
extern "C" {
  pub fn wasm_functype_results(
    arg1: *const wasm_functype_t,
  ) -> *const wasm_valtype_vec_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_globaltype_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_globaltype_delete(arg1: *mut wasm_globaltype_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_globaltype_vec_t {
  pub size: size_t,
  pub data: *mut *mut wasm_globaltype_t,
}
#[test]
fn bindgen_test_layout_wasm_globaltype_vec_t() {
  assert_eq!(
    ::std::mem::size_of::<wasm_globaltype_vec_t>(),
    16usize,
    concat!("Size of: ", stringify!(wasm_globaltype_vec_t))
  );
  assert_eq!(
    ::std::mem::align_of::<wasm_globaltype_vec_t>(),
    8usize,
    concat!("Alignment of ", stringify!(wasm_globaltype_vec_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_globaltype_vec_t>())).size as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_globaltype_vec_t),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_globaltype_vec_t>())).data as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_globaltype_vec_t),
      "::",
      stringify!(data)
    )
  );
}
impl Default for wasm_globaltype_vec_t {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
extern "C" {
  pub fn wasm_globaltype_vec_new_empty(out: *mut wasm_globaltype_vec_t);
}
extern "C" {
  pub fn wasm_globaltype_vec_new_uninitialized(
    out: *mut wasm_globaltype_vec_t,
    arg1: size_t,
  );
}
extern "C" {
  pub fn wasm_globaltype_vec_new(
    out: *mut wasm_globaltype_vec_t,
    arg1: size_t,
    arg2: *const *mut wasm_globaltype_t,
  );
}
extern "C" {
  pub fn wasm_globaltype_vec_copy(
    out: *mut wasm_globaltype_vec_t,
    arg1: *mut wasm_globaltype_vec_t,
  );
}
extern "C" {
  pub fn wasm_globaltype_vec_delete(arg1: *mut wasm_globaltype_vec_t);
}
extern "C" {
  pub fn wasm_globaltype_copy(
    arg1: *mut wasm_globaltype_t,
  ) -> *mut wasm_globaltype_t;
}
extern "C" {
  pub fn wasm_globaltype_new(
    arg1: *mut wasm_valtype_t,
    arg2: wasm_mutability_t,
  ) -> *mut wasm_globaltype_t;
}
extern "C" {
  pub fn wasm_globaltype_content(
    arg1: *const wasm_globaltype_t,
  ) -> *const wasm_valtype_t;
}
extern "C" {
  pub fn wasm_globaltype_mutability(
    arg1: *const wasm_globaltype_t,
  ) -> wasm_mutability_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_tabletype_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_tabletype_delete(arg1: *mut wasm_tabletype_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_tabletype_vec_t {
  pub size: size_t,
  pub data: *mut *mut wasm_tabletype_t,
}
#[test]
fn bindgen_test_layout_wasm_tabletype_vec_t() {
  assert_eq!(
    ::std::mem::size_of::<wasm_tabletype_vec_t>(),
    16usize,
    concat!("Size of: ", stringify!(wasm_tabletype_vec_t))
  );
  assert_eq!(
    ::std::mem::align_of::<wasm_tabletype_vec_t>(),
    8usize,
    concat!("Alignment of ", stringify!(wasm_tabletype_vec_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_tabletype_vec_t>())).size as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_tabletype_vec_t),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_tabletype_vec_t>())).data as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_tabletype_vec_t),
      "::",
      stringify!(data)
    )
  );
}
impl Default for wasm_tabletype_vec_t {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
extern "C" {
  pub fn wasm_tabletype_vec_new_empty(out: *mut wasm_tabletype_vec_t);
}
extern "C" {
  pub fn wasm_tabletype_vec_new_uninitialized(
    out: *mut wasm_tabletype_vec_t,
    arg1: size_t,
  );
}
extern "C" {
  pub fn wasm_tabletype_vec_new(
    out: *mut wasm_tabletype_vec_t,
    arg1: size_t,
    arg2: *const *mut wasm_tabletype_t,
  );
}
extern "C" {
  pub fn wasm_tabletype_vec_copy(
    out: *mut wasm_tabletype_vec_t,
    arg1: *mut wasm_tabletype_vec_t,
  );
}
extern "C" {
  pub fn wasm_tabletype_vec_delete(arg1: *mut wasm_tabletype_vec_t);
}
extern "C" {
  pub fn wasm_tabletype_copy(
    arg1: *mut wasm_tabletype_t,
  ) -> *mut wasm_tabletype_t;
}
extern "C" {
  pub fn wasm_tabletype_new(
    arg1: *mut wasm_valtype_t,
    arg2: *const wasm_limits_t,
  ) -> *mut wasm_tabletype_t;
}
extern "C" {
  pub fn wasm_tabletype_element(
    arg1: *const wasm_tabletype_t,
  ) -> *const wasm_valtype_t;
}
extern "C" {
  pub fn wasm_tabletype_limits(
    arg1: *const wasm_tabletype_t,
  ) -> *const wasm_limits_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_memorytype_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_memorytype_delete(arg1: *mut wasm_memorytype_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_memorytype_vec_t {
  pub size: size_t,
  pub data: *mut *mut wasm_memorytype_t,
}
#[test]
fn bindgen_test_layout_wasm_memorytype_vec_t() {
  assert_eq!(
    ::std::mem::size_of::<wasm_memorytype_vec_t>(),
    16usize,
    concat!("Size of: ", stringify!(wasm_memorytype_vec_t))
  );
  assert_eq!(
    ::std::mem::align_of::<wasm_memorytype_vec_t>(),
    8usize,
    concat!("Alignment of ", stringify!(wasm_memorytype_vec_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_memorytype_vec_t>())).size as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_memorytype_vec_t),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_memorytype_vec_t>())).data as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_memorytype_vec_t),
      "::",
      stringify!(data)
    )
  );
}
impl Default for wasm_memorytype_vec_t {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
extern "C" {
  pub fn wasm_memorytype_vec_new_empty(out: *mut wasm_memorytype_vec_t);
}
extern "C" {
  pub fn wasm_memorytype_vec_new_uninitialized(
    out: *mut wasm_memorytype_vec_t,
    arg1: size_t,
  );
}
extern "C" {
  pub fn wasm_memorytype_vec_new(
    out: *mut wasm_memorytype_vec_t,
    arg1: size_t,
    arg2: *const *mut wasm_memorytype_t,
  );
}
extern "C" {
  pub fn wasm_memorytype_vec_copy(
    out: *mut wasm_memorytype_vec_t,
    arg1: *mut wasm_memorytype_vec_t,
  );
}
extern "C" {
  pub fn wasm_memorytype_vec_delete(arg1: *mut wasm_memorytype_vec_t);
}
extern "C" {
  pub fn wasm_memorytype_copy(
    arg1: *mut wasm_memorytype_t,
  ) -> *mut wasm_memorytype_t;
}
extern "C" {
  pub fn wasm_memorytype_new(
    arg1: *const wasm_limits_t,
  ) -> *mut wasm_memorytype_t;
}
extern "C" {
  pub fn wasm_memorytype_limits(
    arg1: *const wasm_memorytype_t,
  ) -> *const wasm_limits_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_externtype_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_externtype_delete(arg1: *mut wasm_externtype_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_externtype_vec_t {
  pub size: size_t,
  pub data: *mut *mut wasm_externtype_t,
}
#[test]
fn bindgen_test_layout_wasm_externtype_vec_t() {
  assert_eq!(
    ::std::mem::size_of::<wasm_externtype_vec_t>(),
    16usize,
    concat!("Size of: ", stringify!(wasm_externtype_vec_t))
  );
  assert_eq!(
    ::std::mem::align_of::<wasm_externtype_vec_t>(),
    8usize,
    concat!("Alignment of ", stringify!(wasm_externtype_vec_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_externtype_vec_t>())).size as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_externtype_vec_t),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_externtype_vec_t>())).data as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_externtype_vec_t),
      "::",
      stringify!(data)
    )
  );
}
impl Default for wasm_externtype_vec_t {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
extern "C" {
  pub fn wasm_externtype_vec_new_empty(out: *mut wasm_externtype_vec_t);
}
extern "C" {
  pub fn wasm_externtype_vec_new_uninitialized(
    out: *mut wasm_externtype_vec_t,
    arg1: size_t,
  );
}
extern "C" {
  pub fn wasm_externtype_vec_new(
    out: *mut wasm_externtype_vec_t,
    arg1: size_t,
    arg2: *const *mut wasm_externtype_t,
  );
}
extern "C" {
  pub fn wasm_externtype_vec_copy(
    out: *mut wasm_externtype_vec_t,
    arg1: *mut wasm_externtype_vec_t,
  );
}
extern "C" {
  pub fn wasm_externtype_vec_delete(arg1: *mut wasm_externtype_vec_t);
}
extern "C" {
  pub fn wasm_externtype_copy(
    arg1: *mut wasm_externtype_t,
  ) -> *mut wasm_externtype_t;
}
pub type wasm_externkind_t = u8;
pub const wasm_externkind_enum_WASM_EXTERN_FUNC: wasm_externkind_enum = 0;
pub const wasm_externkind_enum_WASM_EXTERN_GLOBAL: wasm_externkind_enum = 1;
pub const wasm_externkind_enum_WASM_EXTERN_TABLE: wasm_externkind_enum = 2;
pub const wasm_externkind_enum_WASM_EXTERN_MEMORY: wasm_externkind_enum = 3;
pub type wasm_externkind_enum = ::std::os::raw::c_uint;
extern "C" {
  pub fn wasm_externtype_kind(
    arg1: *const wasm_externtype_t,
  ) -> wasm_externkind_t;
}
extern "C" {
  pub fn wasm_functype_as_externtype(
    arg1: *mut wasm_functype_t,
  ) -> *mut wasm_externtype_t;
}
extern "C" {
  pub fn wasm_globaltype_as_externtype(
    arg1: *mut wasm_globaltype_t,
  ) -> *mut wasm_externtype_t;
}
extern "C" {
  pub fn wasm_tabletype_as_externtype(
    arg1: *mut wasm_tabletype_t,
  ) -> *mut wasm_externtype_t;
}
extern "C" {
  pub fn wasm_memorytype_as_externtype(
    arg1: *mut wasm_memorytype_t,
  ) -> *mut wasm_externtype_t;
}
extern "C" {
  pub fn wasm_externtype_as_functype(
    arg1: *mut wasm_externtype_t,
  ) -> *mut wasm_functype_t;
}
extern "C" {
  pub fn wasm_externtype_as_globaltype(
    arg1: *mut wasm_externtype_t,
  ) -> *mut wasm_globaltype_t;
}
extern "C" {
  pub fn wasm_externtype_as_tabletype(
    arg1: *mut wasm_externtype_t,
  ) -> *mut wasm_tabletype_t;
}
extern "C" {
  pub fn wasm_externtype_as_memorytype(
    arg1: *mut wasm_externtype_t,
  ) -> *mut wasm_memorytype_t;
}
extern "C" {
  pub fn wasm_functype_as_externtype_const(
    arg1: *const wasm_functype_t,
  ) -> *const wasm_externtype_t;
}
extern "C" {
  pub fn wasm_globaltype_as_externtype_const(
    arg1: *const wasm_globaltype_t,
  ) -> *const wasm_externtype_t;
}
extern "C" {
  pub fn wasm_tabletype_as_externtype_const(
    arg1: *const wasm_tabletype_t,
  ) -> *const wasm_externtype_t;
}
extern "C" {
  pub fn wasm_memorytype_as_externtype_const(
    arg1: *const wasm_memorytype_t,
  ) -> *const wasm_externtype_t;
}
extern "C" {
  pub fn wasm_externtype_as_functype_const(
    arg1: *const wasm_externtype_t,
  ) -> *const wasm_functype_t;
}
extern "C" {
  pub fn wasm_externtype_as_globaltype_const(
    arg1: *const wasm_externtype_t,
  ) -> *const wasm_globaltype_t;
}
extern "C" {
  pub fn wasm_externtype_as_tabletype_const(
    arg1: *const wasm_externtype_t,
  ) -> *const wasm_tabletype_t;
}
extern "C" {
  pub fn wasm_externtype_as_memorytype_const(
    arg1: *const wasm_externtype_t,
  ) -> *const wasm_memorytype_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_importtype_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_importtype_delete(arg1: *mut wasm_importtype_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_importtype_vec_t {
  pub size: size_t,
  pub data: *mut *mut wasm_importtype_t,
}
#[test]
fn bindgen_test_layout_wasm_importtype_vec_t() {
  assert_eq!(
    ::std::mem::size_of::<wasm_importtype_vec_t>(),
    16usize,
    concat!("Size of: ", stringify!(wasm_importtype_vec_t))
  );
  assert_eq!(
    ::std::mem::align_of::<wasm_importtype_vec_t>(),
    8usize,
    concat!("Alignment of ", stringify!(wasm_importtype_vec_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_importtype_vec_t>())).size as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_importtype_vec_t),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_importtype_vec_t>())).data as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_importtype_vec_t),
      "::",
      stringify!(data)
    )
  );
}
impl Default for wasm_importtype_vec_t {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
extern "C" {
  pub fn wasm_importtype_vec_new_empty(out: *mut wasm_importtype_vec_t);
}
extern "C" {
  pub fn wasm_importtype_vec_new_uninitialized(
    out: *mut wasm_importtype_vec_t,
    arg1: size_t,
  );
}
extern "C" {
  pub fn wasm_importtype_vec_new(
    out: *mut wasm_importtype_vec_t,
    arg1: size_t,
    arg2: *const *mut wasm_importtype_t,
  );
}
extern "C" {
  pub fn wasm_importtype_vec_copy(
    out: *mut wasm_importtype_vec_t,
    arg1: *mut wasm_importtype_vec_t,
  );
}
extern "C" {
  pub fn wasm_importtype_vec_delete(arg1: *mut wasm_importtype_vec_t);
}
extern "C" {
  pub fn wasm_importtype_copy(
    arg1: *mut wasm_importtype_t,
  ) -> *mut wasm_importtype_t;
}
extern "C" {
  pub fn wasm_importtype_new(
    module: *mut wasm_name_t,
    name: *mut wasm_name_t,
    arg1: *mut wasm_externtype_t,
  ) -> *mut wasm_importtype_t;
}
extern "C" {
  pub fn wasm_importtype_module(
    arg1: *const wasm_importtype_t,
  ) -> *const wasm_name_t;
}
extern "C" {
  pub fn wasm_importtype_name(
    arg1: *const wasm_importtype_t,
  ) -> *const wasm_name_t;
}
extern "C" {
  pub fn wasm_importtype_type(
    arg1: *const wasm_importtype_t,
  ) -> *const wasm_externtype_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_exporttype_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_exporttype_delete(arg1: *mut wasm_exporttype_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_exporttype_vec_t {
  pub size: size_t,
  pub data: *mut *mut wasm_exporttype_t,
}
#[test]
fn bindgen_test_layout_wasm_exporttype_vec_t() {
  assert_eq!(
    ::std::mem::size_of::<wasm_exporttype_vec_t>(),
    16usize,
    concat!("Size of: ", stringify!(wasm_exporttype_vec_t))
  );
  assert_eq!(
    ::std::mem::align_of::<wasm_exporttype_vec_t>(),
    8usize,
    concat!("Alignment of ", stringify!(wasm_exporttype_vec_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_exporttype_vec_t>())).size as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_exporttype_vec_t),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_exporttype_vec_t>())).data as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_exporttype_vec_t),
      "::",
      stringify!(data)
    )
  );
}
impl Default for wasm_exporttype_vec_t {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
extern "C" {
  pub fn wasm_exporttype_vec_new_empty(out: *mut wasm_exporttype_vec_t);
}
extern "C" {
  pub fn wasm_exporttype_vec_new_uninitialized(
    out: *mut wasm_exporttype_vec_t,
    arg1: size_t,
  );
}
extern "C" {
  pub fn wasm_exporttype_vec_new(
    out: *mut wasm_exporttype_vec_t,
    arg1: size_t,
    arg2: *const *mut wasm_exporttype_t,
  );
}
extern "C" {
  pub fn wasm_exporttype_vec_copy(
    out: *mut wasm_exporttype_vec_t,
    arg1: *mut wasm_exporttype_vec_t,
  );
}
extern "C" {
  pub fn wasm_exporttype_vec_delete(arg1: *mut wasm_exporttype_vec_t);
}
extern "C" {
  pub fn wasm_exporttype_copy(
    arg1: *mut wasm_exporttype_t,
  ) -> *mut wasm_exporttype_t;
}
extern "C" {
  pub fn wasm_exporttype_new(
    arg1: *mut wasm_name_t,
    arg2: *mut wasm_externtype_t,
  ) -> *mut wasm_exporttype_t;
}
extern "C" {
  pub fn wasm_exporttype_name(
    arg1: *const wasm_exporttype_t,
  ) -> *const wasm_name_t;
}
extern "C" {
  pub fn wasm_exporttype_type(
    arg1: *const wasm_exporttype_t,
  ) -> *const wasm_externtype_t;
}
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_ref_t {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wasm_val_t {
  pub kind: wasm_valkind_t,
  pub of: wasm_val_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wasm_val_t__bindgen_ty_1 {
  pub i32_: i32,
  pub i64_: i64,
  pub f32_: float32_t,
  pub f64_: float64_t,
  pub ref_: *mut wasm_ref_t,
}
#[test]
fn bindgen_test_layout_wasm_val_t__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<wasm_val_t__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(wasm_val_t__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<wasm_val_t__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(wasm_val_t__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_val_t__bindgen_ty_1>())).i32_ as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_val_t__bindgen_ty_1),
      "::",
      stringify!(i32_)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_val_t__bindgen_ty_1>())).i64_ as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_val_t__bindgen_ty_1),
      "::",
      stringify!(i64_)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_val_t__bindgen_ty_1>())).f32_ as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_val_t__bindgen_ty_1),
      "::",
      stringify!(f32_)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_val_t__bindgen_ty_1>())).f64_ as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_val_t__bindgen_ty_1),
      "::",
      stringify!(f64_)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_val_t__bindgen_ty_1>())).ref_ as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_val_t__bindgen_ty_1),
      "::",
      stringify!(ref_)
    )
  );
}
impl Default for wasm_val_t__bindgen_ty_1 {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[test]
fn bindgen_test_layout_wasm_val_t() {
  assert_eq!(
    ::std::mem::size_of::<wasm_val_t>(),
    16usize,
    concat!("Size of: ", stringify!(wasm_val_t))
  );
  assert_eq!(
    ::std::mem::align_of::<wasm_val_t>(),
    8usize,
    concat!("Alignment of ", stringify!(wasm_val_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<wasm_val_t>())).kind as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_val_t),
      "::",
      stringify!(kind)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<wasm_val_t>())).of as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_val_t),
      "::",
      stringify!(of)
    )
  );
}
impl Default for wasm_val_t {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
extern "C" {
  pub fn wasm_val_delete(v: *mut wasm_val_t);
}
extern "C" {
  pub fn wasm_val_copy(out: *mut wasm_val_t, arg1: *const wasm_val_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_val_vec_t {
  pub size: size_t,
  pub data: *mut wasm_val_t,
}
#[test]
fn bindgen_test_layout_wasm_val_vec_t() {
  assert_eq!(
    ::std::mem::size_of::<wasm_val_vec_t>(),
    16usize,
    concat!("Size of: ", stringify!(wasm_val_vec_t))
  );
  assert_eq!(
    ::std::mem::align_of::<wasm_val_vec_t>(),
    8usize,
    concat!("Alignment of ", stringify!(wasm_val_vec_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_val_vec_t>())).size as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_val_vec_t),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_val_vec_t>())).data as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_val_vec_t),
      "::",
      stringify!(data)
    )
  );
}
impl Default for wasm_val_vec_t {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
extern "C" {
  pub fn wasm_val_vec_new_empty(out: *mut wasm_val_vec_t);
}
extern "C" {
  pub fn wasm_val_vec_new_uninitialized(out: *mut wasm_val_vec_t, arg1: size_t);
}
extern "C" {
  pub fn wasm_val_vec_new(
    out: *mut wasm_val_vec_t,
    arg1: size_t,
    arg2: *const wasm_val_t,
  );
}
extern "C" {
  pub fn wasm_val_vec_copy(out: *mut wasm_val_vec_t, arg1: *mut wasm_val_vec_t);
}
extern "C" {
  pub fn wasm_val_vec_delete(arg1: *mut wasm_val_vec_t);
}
extern "C" {
  pub fn wasm_ref_delete(arg1: *mut wasm_ref_t);
}
extern "C" {
  pub fn wasm_ref_copy(arg1: *const wasm_ref_t) -> *mut wasm_ref_t;
}
extern "C" {
  pub fn wasm_ref_same(
    arg1: *const wasm_ref_t,
    arg2: *const wasm_ref_t,
  ) -> bool;
}
extern "C" {
  pub fn wasm_ref_get_host_info(
    arg1: *const wasm_ref_t,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn wasm_ref_set_host_info(
    arg1: *mut wasm_ref_t,
    arg2: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn wasm_ref_set_host_info_with_finalizer(
    arg1: *mut wasm_ref_t,
    arg2: *mut ::std::os::raw::c_void,
    arg3: ::std::option::Option<
      unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
    >,
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_frame_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_frame_delete(arg1: *mut wasm_frame_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_frame_vec_t {
  pub size: size_t,
  pub data: *mut *mut wasm_frame_t,
}
#[test]
fn bindgen_test_layout_wasm_frame_vec_t() {
  assert_eq!(
    ::std::mem::size_of::<wasm_frame_vec_t>(),
    16usize,
    concat!("Size of: ", stringify!(wasm_frame_vec_t))
  );
  assert_eq!(
    ::std::mem::align_of::<wasm_frame_vec_t>(),
    8usize,
    concat!("Alignment of ", stringify!(wasm_frame_vec_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_frame_vec_t>())).size as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_frame_vec_t),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_frame_vec_t>())).data as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_frame_vec_t),
      "::",
      stringify!(data)
    )
  );
}
impl Default for wasm_frame_vec_t {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
extern "C" {
  pub fn wasm_frame_vec_new_empty(out: *mut wasm_frame_vec_t);
}
extern "C" {
  pub fn wasm_frame_vec_new_uninitialized(
    out: *mut wasm_frame_vec_t,
    arg1: size_t,
  );
}
extern "C" {
  pub fn wasm_frame_vec_new(
    out: *mut wasm_frame_vec_t,
    arg1: size_t,
    arg2: *const *mut wasm_frame_t,
  );
}
extern "C" {
  pub fn wasm_frame_vec_copy(
    out: *mut wasm_frame_vec_t,
    arg1: *mut wasm_frame_vec_t,
  );
}
extern "C" {
  pub fn wasm_frame_vec_delete(arg1: *mut wasm_frame_vec_t);
}
extern "C" {
  pub fn wasm_frame_copy(arg1: *const wasm_frame_t) -> *mut wasm_frame_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_instance_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_frame_instance(arg1: *const wasm_frame_t)
    -> *mut wasm_instance_t;
}
extern "C" {
  pub fn wasm_frame_func_index(arg1: *const wasm_frame_t) -> u32;
}
extern "C" {
  pub fn wasm_frame_func_offset(arg1: *const wasm_frame_t) -> size_t;
}
extern "C" {
  pub fn wasm_frame_module_offset(arg1: *const wasm_frame_t) -> size_t;
}
pub type wasm_message_t = wasm_name_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_trap_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_trap_delete(arg1: *mut wasm_trap_t);
}
extern "C" {
  pub fn wasm_trap_copy(arg1: *const wasm_trap_t) -> *mut wasm_trap_t;
}
extern "C" {
  pub fn wasm_trap_same(
    arg1: *const wasm_trap_t,
    arg2: *const wasm_trap_t,
  ) -> bool;
}
extern "C" {
  pub fn wasm_trap_get_host_info(
    arg1: *const wasm_trap_t,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn wasm_trap_set_host_info(
    arg1: *mut wasm_trap_t,
    arg2: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn wasm_trap_set_host_info_with_finalizer(
    arg1: *mut wasm_trap_t,
    arg2: *mut ::std::os::raw::c_void,
    arg3: ::std::option::Option<
      unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
    >,
  );
}
extern "C" {
  pub fn wasm_trap_as_ref(arg1: *mut wasm_trap_t) -> *mut wasm_ref_t;
}
extern "C" {
  pub fn wasm_ref_as_trap(arg1: *mut wasm_ref_t) -> *mut wasm_trap_t;
}
extern "C" {
  pub fn wasm_trap_as_ref_const(arg1: *const wasm_trap_t) -> *const wasm_ref_t;
}
extern "C" {
  pub fn wasm_ref_as_trap_const(arg1: *const wasm_ref_t) -> *const wasm_trap_t;
}
extern "C" {
  pub fn wasm_trap_new(
    store: *mut wasm_store_t,
    arg1: *const wasm_message_t,
  ) -> *mut wasm_trap_t;
}
extern "C" {
  pub fn wasm_trap_message(arg1: *const wasm_trap_t, out: *mut wasm_message_t);
}
extern "C" {
  pub fn wasm_trap_origin(arg1: *const wasm_trap_t) -> *mut wasm_frame_t;
}
extern "C" {
  pub fn wasm_trap_trace(arg1: *const wasm_trap_t, out: *mut wasm_frame_vec_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_foreign_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_foreign_delete(arg1: *mut wasm_foreign_t);
}
extern "C" {
  pub fn wasm_foreign_copy(arg1: *const wasm_foreign_t) -> *mut wasm_foreign_t;
}
extern "C" {
  pub fn wasm_foreign_same(
    arg1: *const wasm_foreign_t,
    arg2: *const wasm_foreign_t,
  ) -> bool;
}
extern "C" {
  pub fn wasm_foreign_get_host_info(
    arg1: *const wasm_foreign_t,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn wasm_foreign_set_host_info(
    arg1: *mut wasm_foreign_t,
    arg2: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn wasm_foreign_set_host_info_with_finalizer(
    arg1: *mut wasm_foreign_t,
    arg2: *mut ::std::os::raw::c_void,
    arg3: ::std::option::Option<
      unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
    >,
  );
}
extern "C" {
  pub fn wasm_foreign_as_ref(arg1: *mut wasm_foreign_t) -> *mut wasm_ref_t;
}
extern "C" {
  pub fn wasm_ref_as_foreign(arg1: *mut wasm_ref_t) -> *mut wasm_foreign_t;
}
extern "C" {
  pub fn wasm_foreign_as_ref_const(
    arg1: *const wasm_foreign_t,
  ) -> *const wasm_ref_t;
}
extern "C" {
  pub fn wasm_ref_as_foreign_const(
    arg1: *const wasm_ref_t,
  ) -> *const wasm_foreign_t;
}
extern "C" {
  pub fn wasm_foreign_new(arg1: *mut wasm_store_t) -> *mut wasm_foreign_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_module_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_module_delete(arg1: *mut wasm_module_t);
}
extern "C" {
  pub fn wasm_module_copy(arg1: *const wasm_module_t) -> *mut wasm_module_t;
}
extern "C" {
  pub fn wasm_module_same(
    arg1: *const wasm_module_t,
    arg2: *const wasm_module_t,
  ) -> bool;
}
extern "C" {
  pub fn wasm_module_get_host_info(
    arg1: *const wasm_module_t,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn wasm_module_set_host_info(
    arg1: *mut wasm_module_t,
    arg2: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn wasm_module_set_host_info_with_finalizer(
    arg1: *mut wasm_module_t,
    arg2: *mut ::std::os::raw::c_void,
    arg3: ::std::option::Option<
      unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
    >,
  );
}
extern "C" {
  pub fn wasm_module_as_ref(arg1: *mut wasm_module_t) -> *mut wasm_ref_t;
}
extern "C" {
  pub fn wasm_ref_as_module(arg1: *mut wasm_ref_t) -> *mut wasm_module_t;
}
extern "C" {
  pub fn wasm_module_as_ref_const(
    arg1: *const wasm_module_t,
  ) -> *const wasm_ref_t;
}
extern "C" {
  pub fn wasm_ref_as_module_const(
    arg1: *const wasm_ref_t,
  ) -> *const wasm_module_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_shared_module_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_shared_module_delete(arg1: *mut wasm_shared_module_t);
}
extern "C" {
  pub fn wasm_module_share(
    arg1: *const wasm_module_t,
  ) -> *mut wasm_shared_module_t;
}
extern "C" {
  pub fn wasm_module_obtain(
    arg1: *mut wasm_store_t,
    arg2: *const wasm_shared_module_t,
  ) -> *mut wasm_module_t;
}
extern "C" {
  pub fn wasm_module_new(
    arg1: *mut wasm_store_t,
    binary: *const wasm_byte_vec_t,
  ) -> *mut wasm_module_t;
}
extern "C" {
  pub fn wasm_module_validate(
    arg1: *mut wasm_store_t,
    binary: *const wasm_byte_vec_t,
  ) -> bool;
}
extern "C" {
  pub fn wasm_module_imports(
    arg1: *const wasm_module_t,
    out: *mut wasm_importtype_vec_t,
  );
}
extern "C" {
  pub fn wasm_module_exports(
    arg1: *const wasm_module_t,
    out: *mut wasm_exporttype_vec_t,
  );
}
extern "C" {
  pub fn wasm_module_serialize(
    arg1: *const wasm_module_t,
    out: *mut wasm_byte_vec_t,
  );
}
extern "C" {
  pub fn wasm_module_deserialize(
    arg1: *mut wasm_store_t,
    arg2: *const wasm_byte_vec_t,
  ) -> *mut wasm_module_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_func_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_func_delete(arg1: *mut wasm_func_t);
}
extern "C" {
  pub fn wasm_func_copy(arg1: *const wasm_func_t) -> *mut wasm_func_t;
}
extern "C" {
  pub fn wasm_func_same(
    arg1: *const wasm_func_t,
    arg2: *const wasm_func_t,
  ) -> bool;
}
extern "C" {
  pub fn wasm_func_get_host_info(
    arg1: *const wasm_func_t,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn wasm_func_set_host_info(
    arg1: *mut wasm_func_t,
    arg2: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn wasm_func_set_host_info_with_finalizer(
    arg1: *mut wasm_func_t,
    arg2: *mut ::std::os::raw::c_void,
    arg3: ::std::option::Option<
      unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
    >,
  );
}
extern "C" {
  pub fn wasm_func_as_ref(arg1: *mut wasm_func_t) -> *mut wasm_ref_t;
}
extern "C" {
  pub fn wasm_ref_as_func(arg1: *mut wasm_ref_t) -> *mut wasm_func_t;
}
extern "C" {
  pub fn wasm_func_as_ref_const(arg1: *const wasm_func_t) -> *const wasm_ref_t;
}
extern "C" {
  pub fn wasm_ref_as_func_const(arg1: *const wasm_ref_t) -> *const wasm_func_t;
}
pub type wasm_func_callback_t = ::std::option::Option<
  unsafe extern "C" fn(
    args: *const wasm_val_t,
    results: *mut wasm_val_t,
  ) -> *mut wasm_trap_t,
>;
pub type wasm_func_callback_with_env_t = ::std::option::Option<
  unsafe extern "C" fn(
    env: *mut ::std::os::raw::c_void,
    args: *const wasm_val_t,
    results: *mut wasm_val_t,
  ) -> *mut wasm_trap_t,
>;
extern "C" {
  pub fn wasm_func_new(
    arg1: *mut wasm_store_t,
    arg2: *const wasm_functype_t,
    arg3: wasm_func_callback_t,
  ) -> *mut wasm_func_t;
}
extern "C" {
  pub fn wasm_func_new_with_env(
    arg1: *mut wasm_store_t,
    type_: *const wasm_functype_t,
    arg2: wasm_func_callback_with_env_t,
    env: *mut ::std::os::raw::c_void,
    finalizer: ::std::option::Option<
      unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
    >,
  ) -> *mut wasm_func_t;
}
extern "C" {
  pub fn wasm_func_type(arg1: *const wasm_func_t) -> *mut wasm_functype_t;
}
extern "C" {
  pub fn wasm_func_param_arity(arg1: *const wasm_func_t) -> size_t;
}
extern "C" {
  pub fn wasm_func_result_arity(arg1: *const wasm_func_t) -> size_t;
}
extern "C" {
  pub fn wasm_func_call(
    arg1: *const wasm_func_t,
    args: *const wasm_val_t,
    results: *mut wasm_val_t,
  ) -> *mut wasm_trap_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_global_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_global_delete(arg1: *mut wasm_global_t);
}
extern "C" {
  pub fn wasm_global_copy(arg1: *const wasm_global_t) -> *mut wasm_global_t;
}
extern "C" {
  pub fn wasm_global_same(
    arg1: *const wasm_global_t,
    arg2: *const wasm_global_t,
  ) -> bool;
}
extern "C" {
  pub fn wasm_global_get_host_info(
    arg1: *const wasm_global_t,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn wasm_global_set_host_info(
    arg1: *mut wasm_global_t,
    arg2: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn wasm_global_set_host_info_with_finalizer(
    arg1: *mut wasm_global_t,
    arg2: *mut ::std::os::raw::c_void,
    arg3: ::std::option::Option<
      unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
    >,
  );
}
extern "C" {
  pub fn wasm_global_as_ref(arg1: *mut wasm_global_t) -> *mut wasm_ref_t;
}
extern "C" {
  pub fn wasm_ref_as_global(arg1: *mut wasm_ref_t) -> *mut wasm_global_t;
}
extern "C" {
  pub fn wasm_global_as_ref_const(
    arg1: *const wasm_global_t,
  ) -> *const wasm_ref_t;
}
extern "C" {
  pub fn wasm_ref_as_global_const(
    arg1: *const wasm_ref_t,
  ) -> *const wasm_global_t;
}
extern "C" {
  pub fn wasm_global_new(
    arg1: *mut wasm_store_t,
    arg2: *const wasm_globaltype_t,
    arg3: *const wasm_val_t,
  ) -> *mut wasm_global_t;
}
extern "C" {
  pub fn wasm_global_type(arg1: *const wasm_global_t)
    -> *mut wasm_globaltype_t;
}
extern "C" {
  pub fn wasm_global_get(arg1: *const wasm_global_t, out: *mut wasm_val_t);
}
extern "C" {
  pub fn wasm_global_set(arg1: *mut wasm_global_t, arg2: *const wasm_val_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_table_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_table_delete(arg1: *mut wasm_table_t);
}
extern "C" {
  pub fn wasm_table_copy(arg1: *const wasm_table_t) -> *mut wasm_table_t;
}
extern "C" {
  pub fn wasm_table_same(
    arg1: *const wasm_table_t,
    arg2: *const wasm_table_t,
  ) -> bool;
}
extern "C" {
  pub fn wasm_table_get_host_info(
    arg1: *const wasm_table_t,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn wasm_table_set_host_info(
    arg1: *mut wasm_table_t,
    arg2: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn wasm_table_set_host_info_with_finalizer(
    arg1: *mut wasm_table_t,
    arg2: *mut ::std::os::raw::c_void,
    arg3: ::std::option::Option<
      unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
    >,
  );
}
extern "C" {
  pub fn wasm_table_as_ref(arg1: *mut wasm_table_t) -> *mut wasm_ref_t;
}
extern "C" {
  pub fn wasm_ref_as_table(arg1: *mut wasm_ref_t) -> *mut wasm_table_t;
}
extern "C" {
  pub fn wasm_table_as_ref_const(
    arg1: *const wasm_table_t,
  ) -> *const wasm_ref_t;
}
extern "C" {
  pub fn wasm_ref_as_table_const(
    arg1: *const wasm_ref_t,
  ) -> *const wasm_table_t;
}
pub type wasm_table_size_t = u32;
extern "C" {
  pub fn wasm_table_new(
    arg1: *mut wasm_store_t,
    arg2: *const wasm_tabletype_t,
    init: *mut wasm_ref_t,
  ) -> *mut wasm_table_t;
}
extern "C" {
  pub fn wasm_table_type(arg1: *const wasm_table_t) -> *mut wasm_tabletype_t;
}
extern "C" {
  pub fn wasm_table_get(
    arg1: *const wasm_table_t,
    index: wasm_table_size_t,
  ) -> *mut wasm_ref_t;
}
extern "C" {
  pub fn wasm_table_set(
    arg1: *mut wasm_table_t,
    index: wasm_table_size_t,
    arg2: *mut wasm_ref_t,
  ) -> bool;
}
extern "C" {
  pub fn wasm_table_size(arg1: *const wasm_table_t) -> wasm_table_size_t;
}
extern "C" {
  pub fn wasm_table_grow(
    arg1: *mut wasm_table_t,
    delta: wasm_table_size_t,
    init: *mut wasm_ref_t,
  ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_memory_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_memory_delete(arg1: *mut wasm_memory_t);
}
extern "C" {
  pub fn wasm_memory_copy(arg1: *const wasm_memory_t) -> *mut wasm_memory_t;
}
extern "C" {
  pub fn wasm_memory_same(
    arg1: *const wasm_memory_t,
    arg2: *const wasm_memory_t,
  ) -> bool;
}
extern "C" {
  pub fn wasm_memory_get_host_info(
    arg1: *const wasm_memory_t,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn wasm_memory_set_host_info(
    arg1: *mut wasm_memory_t,
    arg2: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn wasm_memory_set_host_info_with_finalizer(
    arg1: *mut wasm_memory_t,
    arg2: *mut ::std::os::raw::c_void,
    arg3: ::std::option::Option<
      unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
    >,
  );
}
extern "C" {
  pub fn wasm_memory_as_ref(arg1: *mut wasm_memory_t) -> *mut wasm_ref_t;
}
extern "C" {
  pub fn wasm_ref_as_memory(arg1: *mut wasm_ref_t) -> *mut wasm_memory_t;
}
extern "C" {
  pub fn wasm_memory_as_ref_const(
    arg1: *const wasm_memory_t,
  ) -> *const wasm_ref_t;
}
extern "C" {
  pub fn wasm_ref_as_memory_const(
    arg1: *const wasm_ref_t,
  ) -> *const wasm_memory_t;
}
pub type wasm_memory_pages_t = u32;
pub const MEMORY_PAGE_SIZE: size_t = 65536;
extern "C" {
  pub fn wasm_memory_new(
    arg1: *mut wasm_store_t,
    arg2: *const wasm_memorytype_t,
  ) -> *mut wasm_memory_t;
}
extern "C" {
  pub fn wasm_memory_type(arg1: *const wasm_memory_t)
    -> *mut wasm_memorytype_t;
}
extern "C" {
  pub fn wasm_memory_data(arg1: *mut wasm_memory_t) -> *mut byte_t;
}
extern "C" {
  pub fn wasm_memory_data_size(arg1: *const wasm_memory_t) -> size_t;
}
extern "C" {
  pub fn wasm_memory_size(arg1: *const wasm_memory_t) -> wasm_memory_pages_t;
}
extern "C" {
  pub fn wasm_memory_grow(
    arg1: *mut wasm_memory_t,
    delta: wasm_memory_pages_t,
  ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_extern_t {
  _unused: [u8; 0],
}
extern "C" {
  pub fn wasm_extern_delete(arg1: *mut wasm_extern_t);
}
extern "C" {
  pub fn wasm_extern_copy(arg1: *const wasm_extern_t) -> *mut wasm_extern_t;
}
extern "C" {
  pub fn wasm_extern_same(
    arg1: *const wasm_extern_t,
    arg2: *const wasm_extern_t,
  ) -> bool;
}
extern "C" {
  pub fn wasm_extern_get_host_info(
    arg1: *const wasm_extern_t,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn wasm_extern_set_host_info(
    arg1: *mut wasm_extern_t,
    arg2: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn wasm_extern_set_host_info_with_finalizer(
    arg1: *mut wasm_extern_t,
    arg2: *mut ::std::os::raw::c_void,
    arg3: ::std::option::Option<
      unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
    >,
  );
}
extern "C" {
  pub fn wasm_extern_as_ref(arg1: *mut wasm_extern_t) -> *mut wasm_ref_t;
}
extern "C" {
  pub fn wasm_ref_as_extern(arg1: *mut wasm_ref_t) -> *mut wasm_extern_t;
}
extern "C" {
  pub fn wasm_extern_as_ref_const(
    arg1: *const wasm_extern_t,
  ) -> *const wasm_ref_t;
}
extern "C" {
  pub fn wasm_ref_as_extern_const(
    arg1: *const wasm_ref_t,
  ) -> *const wasm_extern_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wasm_extern_vec_t {
  pub size: size_t,
  pub data: *mut *mut wasm_extern_t,
}
#[test]
fn bindgen_test_layout_wasm_extern_vec_t() {
  assert_eq!(
    ::std::mem::size_of::<wasm_extern_vec_t>(),
    16usize,
    concat!("Size of: ", stringify!(wasm_extern_vec_t))
  );
  assert_eq!(
    ::std::mem::align_of::<wasm_extern_vec_t>(),
    8usize,
    concat!("Alignment of ", stringify!(wasm_extern_vec_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_extern_vec_t>())).size as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_extern_vec_t),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<wasm_extern_vec_t>())).data as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(wasm_extern_vec_t),
      "::",
      stringify!(data)
    )
  );
}
impl Default for wasm_extern_vec_t {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
extern "C" {
  pub fn wasm_extern_vec_new_empty(out: *mut wasm_extern_vec_t);
}
extern "C" {
  pub fn wasm_extern_vec_new_uninitialized(
    out: *mut wasm_extern_vec_t,
    arg1: size_t,
  );
}
extern "C" {
  pub fn wasm_extern_vec_new(
    out: *mut wasm_extern_vec_t,
    arg1: size_t,
    arg2: *const *mut wasm_extern_t,
  );
}
extern "C" {
  pub fn wasm_extern_vec_copy(
    out: *mut wasm_extern_vec_t,
    arg1: *mut wasm_extern_vec_t,
  );
}
extern "C" {
  pub fn wasm_extern_vec_delete(arg1: *mut wasm_extern_vec_t);
}
extern "C" {
  pub fn wasm_extern_kind(arg1: *const wasm_extern_t) -> wasm_externkind_t;
}
extern "C" {
  pub fn wasm_extern_type(arg1: *const wasm_extern_t)
    -> *mut wasm_externtype_t;
}
extern "C" {
  pub fn wasm_func_as_extern(arg1: *mut wasm_func_t) -> *mut wasm_extern_t;
}
extern "C" {
  pub fn wasm_global_as_extern(arg1: *mut wasm_global_t) -> *mut wasm_extern_t;
}
extern "C" {
  pub fn wasm_table_as_extern(arg1: *mut wasm_table_t) -> *mut wasm_extern_t;
}
extern "C" {
  pub fn wasm_memory_as_extern(arg1: *mut wasm_memory_t) -> *mut wasm_extern_t;
}
extern "C" {
  pub fn wasm_extern_as_func(arg1: *mut wasm_extern_t) -> *mut wasm_func_t;
}
extern "C" {
  pub fn wasm_extern_as_global(arg1: *mut wasm_extern_t) -> *mut wasm_global_t;
}
extern "C" {
  pub fn wasm_extern_as_table(arg1: *mut wasm_extern_t) -> *mut wasm_table_t;
}
extern "C" {
  pub fn wasm_extern_as_memory(arg1: *mut wasm_extern_t) -> *mut wasm_memory_t;
}
extern "C" {
  pub fn wasm_func_as_extern_const(
    arg1: *const wasm_func_t,
  ) -> *const wasm_extern_t;
}
extern "C" {
  pub fn wasm_global_as_extern_const(
    arg1: *const wasm_global_t,
  ) -> *const wasm_extern_t;
}
extern "C" {
  pub fn wasm_table_as_extern_const(
    arg1: *const wasm_table_t,
  ) -> *const wasm_extern_t;
}
extern "C" {
  pub fn wasm_memory_as_extern_const(
    arg1: *const wasm_memory_t,
  ) -> *const wasm_extern_t;
}
extern "C" {
  pub fn wasm_extern_as_func_const(
    arg1: *const wasm_extern_t,
  ) -> *const wasm_func_t;
}
extern "C" {
  pub fn wasm_extern_as_global_const(
    arg1: *const wasm_extern_t,
  ) -> *const wasm_global_t;
}
extern "C" {
  pub fn wasm_extern_as_table_const(
    arg1: *const wasm_extern_t,
  ) -> *const wasm_table_t;
}
extern "C" {
  pub fn wasm_extern_as_memory_const(
    arg1: *const wasm_extern_t,
  ) -> *const wasm_memory_t;
}
extern "C" {
  pub fn wasm_instance_delete(arg1: *mut wasm_instance_t);
}
extern "C" {
  pub fn wasm_instance_copy(
    arg1: *const wasm_instance_t,
  ) -> *mut wasm_instance_t;
}
extern "C" {
  pub fn wasm_instance_same(
    arg1: *const wasm_instance_t,
    arg2: *const wasm_instance_t,
  ) -> bool;
}
extern "C" {
  pub fn wasm_instance_get_host_info(
    arg1: *const wasm_instance_t,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn wasm_instance_set_host_info(
    arg1: *mut wasm_instance_t,
    arg2: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn wasm_instance_set_host_info_with_finalizer(
    arg1: *mut wasm_instance_t,
    arg2: *mut ::std::os::raw::c_void,
    arg3: ::std::option::Option<
      unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
    >,
  );
}
extern "C" {
  pub fn wasm_instance_as_ref(arg1: *mut wasm_instance_t) -> *mut wasm_ref_t;
}
extern "C" {
  pub fn wasm_ref_as_instance(arg1: *mut wasm_ref_t) -> *mut wasm_instance_t;
}
extern "C" {
  pub fn wasm_instance_as_ref_const(
    arg1: *const wasm_instance_t,
  ) -> *const wasm_ref_t;
}
extern "C" {
  pub fn wasm_ref_as_instance_const(
    arg1: *const wasm_ref_t,
  ) -> *const wasm_instance_t;
}
extern "C" {
  pub fn wasm_instance_new(
    arg1: *mut wasm_store_t,
    arg2: *const wasm_module_t,
    imports: *const *const wasm_extern_t,
    arg3: *mut *mut wasm_trap_t,
  ) -> *mut wasm_instance_t;
}
extern "C" {
  pub fn wasm_instance_exports(
    arg1: *const wasm_instance_t,
    out: *mut wasm_extern_vec_t,
  );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
  pub gp_offset: ::std::os::raw::c_uint,
  pub fp_offset: ::std::os::raw::c_uint,
  pub overflow_arg_area: *mut ::std::os::raw::c_void,
  pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
  assert_eq!(
    ::std::mem::size_of::<__va_list_tag>(),
    24usize,
    concat!("Size of: ", stringify!(__va_list_tag))
  );
  assert_eq!(
    ::std::mem::align_of::<__va_list_tag>(),
    8usize,
    concat!("Alignment of ", stringify!(__va_list_tag))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(gp_offset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(fp_offset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(overflow_arg_area)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(reg_save_area)
    )
  );
}
impl Default for __va_list_tag {
  fn default() -> Self {
    let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
